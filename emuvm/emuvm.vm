entry

~ initialise the cpu and start the machine running
$main
    call init_cpu
    call load_prog
    print 10

    $mainloop
        eq 0 running            ~ make sure we are still running
        hopt end

        mv *pc a                ~ fetch the instruction from the pc 
        call run_instruction    ~ run the instruction we fetched
        mv r running            ~ move the return status to runnin
        add 1 pc                ~ move to the next instruction

        hop mainloop

$end
    print 10
    exit

~ set the stack pointer and base pointer to the end of ram
$init_cpu
    mv &ram_end vsp
    mv vsp vbp

    mv &ram pc

    ret

~~~~~~~~~ variables ~~~~~~~~~
$ram 
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
$ram_end

$pc 0 
$flg 0
$vsp 0
$vbp 0
    
$running 1
$op_error 0

$program
    "push 30"
    "call 1 fib"
    "printn"
    "exit"

    "$fib"
        "sld 3"
        "push 0"
        "eq"
        "hopf fib_base"
        "push 0"
        "ret"

    "$fib_base"
        "sld 3"
        "push 3"
        "lt"
        "hopf fib_calc"
        "push 1"
        "ret"

    "$fib_calc"
        "sld 3"
        "push 1"
        "sub"
        "call 1 fib"

        "sld 3"
        "push 2"
        "sub"
        "call 1 fib"

        "add"
        "ret"

    "end"

