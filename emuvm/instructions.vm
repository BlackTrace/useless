
~ nop instruction, do nothing, return success
$vnop 
    mv 0 r
    ret

~ push instruction, decrement the sp (grow stack) and place
~ the provided argument to where the sp points, return success
$vpush
    sub 1 vsp
    add 1 pc
    mv *pc *vsp
    mv 0 r
    ret

~ array elements consist of operation string, operation index
~ and the number of arguments the operation takes

$op_array
    &nop_str  0 &vnop
    &push_str 1 &vpush
    &pop_str  0 0
    &add_str  0 0
    &sub_str  0 0
    &mul_str  0 0
    &div_str  0 0
$op_array_end


$nop_str    "nop"
$push_str   "push"
$pop_str    "pop"
$add_str    "add"
$sub_str    "sub"
$mul_str    "mul"
$div_str    "div"
$end_str    "end"
    
~ takes string stored in a and uses the op array to turn it
~ into an opcode, return in r
$encode_idx 0
$encode
    push a
    push b
    push c
    
    mv &op_array c              ~ mv start of op array to c
    mv 0 encode_idx
    
    $encode_loop
        mv *c b                 ~ store the string in b for comparison
        call str_equals
        eq 1 r
        hopt encode_found       ~ string matches the token

        eq &op_array_end c      ~ search entire list, to no avail
        hopt encode_not_found
    
        add 1 encode_idx        ~ increment idx by one and pointer by 3 (size of element)
        add 3 c
        hop encode_loop         ~ move to the next item

    $encode_found
        mv encode_idx r
        pop c
        pop b
        pop a
        ret

    $encode_not_found
        call itoa
        pop c
        pop b
        pop a
        ret
    
